# Product Requirements Document (PRD) for civitai-crawler

## Project Summary
civitai-crawler is a backend system for crawling, caching, and querying data from the Civitai API. The system is designed to robustly preserve all API data as raw, unmodified blobs, while extracting and storing only the most relevant fields for fast querying and business logic. This approach ensures resilience to API changes, enables future re-extraction, and supports rapid iteration. The stack is built on Convex (for data storage and workflow orchestration), Zod (for schema validation), and Bun (for scripts and server-side code). R2 or similar object storage will be used for images/assets in the future.

## Goals
- Crawl and cache Civitai models, LoRAs, model versions, and images, along with all associated metadata.
- Store every API response as a stringified blob, preserving all data for future-proofing and debugging.
- Extract and store only the fields needed for querying and business logic in dedicated entity tables.
- Enable fast, reliable querying of cached data (models, LoRAs, images, etc.).
- Be resilient to Civitai API changes and data anomalies.
- Support rate-limiting and queuing of API requests to avoid bans and handle slow/unreliable endpoints.
- Prepare for future asset (image) storage in R2 and a frontend UI for browsing/querying data.

## Core Features
- Fetch and store Civitai models, LoRAs, model versions, and images.
- Store all API results as immutable, append-only blobs, indexed by endpoint, params, entity type, entity ID, and timestamp.
- Use Convex for all structured data storage and queries.
- Use Zod for schema validation and parsing of API responses.
- Extract and store only the most relevant fields from blobs into entity tables for fast access.
- Deduplicate images by URL/hash to avoid storing duplicates.
- Provide a simple, extensible workflow for crawling and updating data.
- Stub out (but do not yet implement) image/asset storage in R2.
- No frontend UI yet; focus is on backend robustness and data coverage.

## Planned Features
- Add rate-limiting, queuing, and scheduled crawling tasks.
- Store images and assets in R2 (or similar object storage).
- Build a frontend UI for querying and browsing cached data.
- Support advanced search and analytics.
- Adapt to new Civitai API features and data types as they emerge.

## Technical Stack
- Convex (database, queries, workflow orchestration)
- Bun (runtime for scripts and server-side code)
- Zod (schema validation)
- R2 (object storage, planned)
- TypeScript

## Design Philosophy
- **Preserve all data:** Store every API response as a raw, unmodified blob for future-proofing, debugging, and re-extraction.
- **Extract only what matters:** Entity tables contain only the fields needed for querying and business logic, extracted from blobs.
- Pure functions, single-purpose, composable code.
- Fail fast: do not catch errors unless necessary; let Convex log errors.
- No return types unless using generics.
- Avoid classes and encapsulation; prefer simple, functional code.
- No need for backwards compatibility; refactor and break as needed.
- Capture and store abnormal API data for manual review.

## Entity Overview
- Model: id, name, description, type, nsfw, stats, creatorUsername, tags, versionIds
- ModelVersion: id, modelId, name, createdAt, baseModel, trainedWords, stats, files, imageIds
- Image: id, url, width, height, nsfw, nsfwLevel, createdAt, postId, stats, meta, username, referencedModels

## Requirements
- Must crawl and store all core Civitai entities (Model, ModelVersion, Image) and their relationships.
- Must store every API response as a raw blob, indexed for traceability.
- Must extract and store only the fields needed for querying in entity tables.
- Must deduplicate images by URL/hash.
- Must support manual and scheduled crawling.
- Must be resilient to API changes and missing/extra fields.
- Must provide a way to query cached data by model, LoRA, etc.
- Must be easy to extend for new entity types or API changes.
- Must not store actual model files, only metadata.
- Must stub out (but not yet implement) image/asset storage in R2.
- Must not include a frontend UI yet.

## Out of Scope
- Downloading and storing actual model files (weights, etc.).
- Frontend UI (to be implemented later).
- Analytics and advanced search (to be implemented later).
- Creator and Tag as first-class entities (may be revisited in the future).

## Architectural Considerations & Open Questions

- **API Result Blob Storage:**
  - All API responses are stored as immutable blobs, indexed by endpoint, params, entity type, entity ID, and timestamp. This enables re-extraction, debugging, and resilience to API changes.
  - Entity tables reference blobs by entityId and endpoint for traceability.
  - No deduplication or storage optimization is performed at this stage; storage is cheap, data loss is expensive.

- **Schema Separation (Raw vs. Normalized Data):**
  - The schema separates raw API blobs from normalized entity tables. Entity tables are lean and fast, while all data is preserved for future-proofing.

- **R2 Image Storage Strategy:**
  - R2 configuration should be prioritized. If we store image assets by Civitai's UUID, we can begin storing images immediately and never need to delete them. However, we may want to offload asset management to a Cloudflare Worker and Queue, where Convex only manages API data and metadata, and the Worker handles downloading and storing images given a source URL and metadata.

- **Convex Components for Workflow:**
  - We plan to use Convex Components to manage workflow steps and orchestration. Research is needed to determine best practices and integration patterns for this approach.

- **Open Questions:**
  - Should we deduplicate blobs if the same entity is fetched multiple times? (Currently, we store all versions for audit/history.)
  - How should we handle parent/child relationships for complex endpoints?
  - What is the best way to link entity tables to their source blobs for traceability? 