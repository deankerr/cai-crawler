/*
  NOTE: The Env type is ambient. It is auto-generated by wrangler.
*/

/**
 * Expected payload structure from Convex when enqueuing a task.
 */
interface EnqueueRequestPayload {
  imageId: string // Convex Id<"images">
  sourceUrl: string
  storageKey: string
}

/**
 * Expected message structure within the Queue.
 */
interface StorageTask {
  imageId: string // Convex Id<"images">
  sourceUrl: string
  storageKey: string
}

export default {
  /**
   * Handles incoming HTTP requests, specifically POST requests from Convex to enqueue tasks.
   */
  async fetch(request: Request, env: Env): Promise<Response> {
    // Only allow POST requests
    if (request.method !== 'POST') {
      return new Response('Method Not Allowed', { status: 405 })
    }

    // Simple routing based on path, could be more sophisticated if needed
    const url = new URL(request.url)
    if (url.pathname !== '/enqueue') {
      return new Response('Not Found', { status: 404 })
    }

    // --- Authentication ---
    const authHeader = request.headers.get('Authorization') || ''
    const token = authHeader.startsWith('Bearer ') ? authHeader.substring(7) : null
    const encoder = new TextEncoder()

    if (!env.ASSETS_SECRET) {
      console.error('ASSETS_SECRET is not set in Worker environment.')
      return new Response('Internal Server Error: Worker configuration missing', { status: 500 })
    }
    if (!token) {
      return new Response('Unauthorized: Missing Authorization header', { status: 401 })
    }

    try {
      const secretBytes = encoder.encode(env.ASSETS_SECRET)
      const tokenBytes = encoder.encode(token)

      // Securely compare secrets
      if (secretBytes.length !== tokenBytes.length || !crypto.subtle.timingSafeEqual(secretBytes, tokenBytes)) {
        return new Response('Unauthorized: Invalid token', { status: 401 })
      }
    }
    catch (e) {
      console.error('Error during authentication comparison:', e)
      return new Response('Internal Server Error during authentication', { status: 500 })
    }

    // --- Payload Validation and Enqueue ---
    let payload: EnqueueRequestPayload
    try {
      payload = await request.json()
      // Add more specific validation if needed (e.g., check types)
      if (!payload.imageId || !payload.sourceUrl || !payload.storageKey) {
        throw new Error('Missing required fields in payload')
      }
    }
    catch (e: any) {
      console.error('Failed to parse or validate request body:', e.message)
      return new Response(`Bad Request: ${e.message}`, { status: 400 })
    }

    try {
      // Use the QUEUE binding from the ambient Env type
      await env.QUEUE.send(payload)
      console.log(`Successfully enqueued task for imageId: ${payload.imageId}`)
      return new Response(JSON.stringify({ success: true }), { headers: { 'Content-Type': 'application/json' } })
    }
    catch (e: any) {
      console.error(`Failed to send message to queue: ${e}`)
      return new Response('Internal Server Error: Failed to enqueue task', { status: 500 })
    }
  },

  /**
   * Handles messages consumed from the Queue.
   */
  async queue(
    // Cast batch to the specific type we expect, overriding the default 'unknown'
    batch: MessageBatch<unknown>,
    env: Env, // Use ambient Env type
  ): Promise<void> {
    console.log(`Processing batch of ${batch.messages.length} messages from queue ${batch.queue}`)

    // Cast the batch again inside the handler if needed for mapping/iteration type safety
    const typedBatch = batch as MessageBatch<StorageTask>

    const promises = typedBatch.messages.map(async (message) => {
      const task = message.body
      console.log(`Processing task for imageId: ${task.imageId}, storageKey: ${task.storageKey}`)

      try {
        // 1. Fetch the asset from the source URL
        const assetResponse = await fetch(task.sourceUrl)
        if (!assetResponse.ok) {
          throw new Error(
            `Failed to fetch asset from ${task.sourceUrl}: ${assetResponse.status} ${assetResponse.statusText}`,
          )
        }
        if (!assetResponse.body) {
          throw new Error(`Fetch response from ${task.sourceUrl} has no body`)
        }

        // 2. Store the asset in R2 using ambient BUCKET binding
        const r2Object = await env.BUCKET.put(task.storageKey, assetResponse.body, {
          httpMetadata: assetResponse.headers,
        })

        if (!r2Object || !r2Object.key) {
          throw new Error(`Failed to put object to R2 for key ${task.storageKey}. R2 returned null or missing key.`)
        }

        console.log(`Successfully stored ${r2Object.key} (Size: ${r2Object.size}) in R2.`)

        // 3. Call back to Convex HTTP endpoint using ambient env vars
        const baseUrl = `https://cai-assets.r2.cloudflarestorage.com` // Using the fallback URL as per user's edit
        const storedUrl = `${baseUrl.replace(/\/$/, '')}/${r2Object.key}`

        const callbackPayload = {
          imageId: task.imageId,
          storageKey: r2Object.key,
          storedUrl,
          size: r2Object.size,
          secret: env.ASSETS_SECRET, // Use ambient ASSETS_SECRET
        }

        if (!env.CONVEX_HTTP_ENDPOINT) {
          console.error('CONVEX_HTTP_ENDPOINT environment variable is not set in Worker.')
          throw new Error('Worker configuration error: Missing Convex callback URL')
        }

        const callbackResponse = await fetch(env.CONVEX_HTTP_ENDPOINT, { // Use ambient CONVEX_HTTP_ENDPOINT
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(callbackPayload),
        })

        if (!callbackResponse.ok) {
          const errorBody = await callbackResponse.text()
          console.error(
            `Failed to call back Convex for imageId ${task.imageId} (Key: ${r2Object.key}): ${callbackResponse.status} ${callbackResponse.statusText} - ${errorBody}`,
          )
          // Decide if queue message should retry on callback failure.
          // Retrying risks duplicate R2 uploads. Consider DLQ for callback issues.
          throw new Error(`Convex callback failed: ${callbackResponse.status}`) // Force retry for now, may adjust later
        }
        else {
          console.log(`Successfully sent callback to Convex for imageId ${task.imageId} (Key: ${r2Object.key})`)
        }

        // Acknowledge the message after successful R2 upload AND successful callback initiation
        message.ack()
      }
      catch (error: any) {
        console.error(
          `Error processing storage task for imageId ${task.imageId} (Key: ${task.storageKey}):`,
          error.message,
        )
        message.retry() // Explicitly tell the queue to retry later on any caught error
      }
    })

    await Promise.allSettled(promises)
    console.log(`Finished processing batch from queue ${batch.queue}`)
  },
}
