/*
  NOTE: The Env type is ambient. It is auto-generated by wrangler.
*/

/**
 * Expected payload structure from Convex when enqueuing a task.
 */
interface EnqueueRequestPayload {
  imageId: string // Convex Id<"images">
  sourceUrl: string
  storageKey: string
}

/**
 * Expected message structure within the Queue.
 */
interface StorageTask {
  imageId: string // Convex Id<"images">
  sourceUrl: string
  storageKey: string
}

export default {
  /**
   * Handles incoming HTTP requests, specifically POST requests from Convex to enqueue tasks.
   */
  async fetch(request: Request, env: Env): Promise<Response> {
    // Only allow POST requests
    if (request.method !== 'POST') {
      return new Response('Method Not Allowed', { status: 405 })
    }

    // Simple routing based on path, could be more sophisticated if needed
    const url = new URL(request.url)
    if (url.pathname !== '/enqueue') {
      return new Response('Not Found', { status: 404 })
    }

    // --- Authentication ---
    const authHeader = request.headers.get('Authorization') || ''
    const token = authHeader.startsWith('Bearer ') ? authHeader.substring(7) : null
    const encoder = new TextEncoder()

    if (!env.ASSETS_SECRET) {
      console.error('ASSETS_SECRET is not set in Worker environment.')
      return new Response('Internal Server Error: Worker configuration missing', { status: 500 })
    }
    if (!token) {
      return new Response('Unauthorized: Missing Authorization header', { status: 401 })
    }

    try {
      const secretBytes = encoder.encode(env.ASSETS_SECRET)
      const tokenBytes = encoder.encode(token)

      // Securely compare secrets
      if (secretBytes.length !== tokenBytes.length || !crypto.subtle.timingSafeEqual(secretBytes, tokenBytes)) {
        return new Response('Unauthorized: Invalid token', { status: 401 })
      }
    }
    catch (e) {
      console.error('Error during authentication comparison:', e)
      return new Response('Internal Server Error during authentication', { status: 500 })
    }

    // --- Payload Validation and Enqueue ---
    let payload: EnqueueRequestPayload
    try {
      payload = await request.json()
      // Add more specific validation if needed (e.g., check types)
      if (!payload.imageId || !payload.sourceUrl || !payload.storageKey) {
        throw new Error('Missing required fields in payload')
      }
    }
    catch (e: any) {
      console.error('Failed to parse or validate request body:', e.message)
      return new Response(`Bad Request: ${e.message}`, { status: 400 })
    }

    try {
      // Use the QUEUE binding from the ambient Env type
      await env.QUEUE.send(payload)
      console.log(`Successfully enqueued task for imageId: ${payload.imageId}`)
      return new Response(JSON.stringify({ success: true }), { headers: { 'Content-Type': 'application/json' } })
    }
    catch (e: any) {
      console.error(`Failed to send message to queue: ${e}`)
      return new Response('Internal Server Error: Failed to enqueue task', { status: 500 })
    }
  },

  /**
   * Handles messages consumed from the Queue.
   * Fetches the asset, stores it in R2, and acknowledges the message.
   * No callback to Convex is performed here.
   */
  async queue(
    batch: MessageBatch<unknown>,
    env: Env,
    ctx: ExecutionContext,
  ): Promise<void> {
    console.log(`Processing batch of ${batch.messages.length} messages from queue ${batch.queue}`)
    const typedBatch = batch as MessageBatch<StorageTask>

    const promises = typedBatch.messages.map(async (message) => {
      const task = message.body
      console.log(`Processing task for imageId: ${task.imageId}, storageKey: ${task.storageKey}`)

      try {
        // 1. Fetch the asset from the source URL
        console.log(`Fetching ${task.sourceUrl}...`)
        const assetResponse = await fetch(task.sourceUrl, { headers: { 'User-Agent': 'CivitaiCrawler/1.0' } }) // Add User-Agent
        if (!assetResponse.ok) {
          throw new Error(
            `Failed to fetch asset from ${task.sourceUrl}: ${assetResponse.status} ${assetResponse.statusText}`,
          )
        }
        if (!assetResponse.body) {
          throw new Error(`Fetch response from ${task.sourceUrl} has no body`)
        }

        // 2. Store the asset in R2 using streaming upload
        console.log(`Storing ${task.storageKey} in R2...`)
        const r2Object = await env.BUCKET.put(task.storageKey, assetResponse.body, {
          httpMetadata: assetResponse.headers,
        })

        if (!r2Object || !r2Object.key) {
          throw new Error(`Failed to put object to R2 for key ${task.storageKey}. R2 put returned null or missing key.`)
        }

        console.log(`Successfully stored ${r2Object.key} (Size: ${r2Object.size}) in R2 for imageId ${task.imageId}.`)

        // 3. Acknowledge the message - Success!
        message.ack()
        console.log(`Acknowledged message for imageId ${task.imageId}`)
      }
      catch (error: any) {
        console.error(
          `FAILED processing storage task for imageId ${task.imageId} (Key: ${task.storageKey}):`,
          error.message,
        )
        // Explicitly retry the message on any caught error during fetch or put
        message.retry()
        console.log(`Retrying message for imageId ${task.imageId}`)
      }
    })

    await Promise.allSettled(promises)
    console.log(`Finished processing batch from queue ${batch.queue}`)
  },
}
