---
description: 
globs: 
alwaysApply: true
---
# Project: cai-crawler

- Store assets and generation data collected from the CivitAI API, with a strategy geared towards data preservation
- The CivitAI database and API have evolved organically over time, as the generative AI field has rapidly evolved, resulting in a large amount of variance in the data structures
- Image generation metadata is particularly difficult to parse, with desired information like models used (Checkpoints, LoRAs) being declared in different formats, or not at all
- Convex is used to orchestrate the system and store entity data, and Cloudflare R2 stores assets using a Queue and Worker to retrieve assets via URL from their CDN
- Current query patterns are to paginate through the API by a model or model version id, or username, storing a large number of the most popular associated images
- Any entity can have a lot of data associated with it - our strategy is to store the payload response in full in a stringified form, then creating our linked representation of the entity by processing the data in a second step
- This lets us continue with collecting results without being halted by validation issues, and enabling us to enrich our entities over time without being dependant on CivitAI
- Our functions should be idempotent where possible, allowing us to re-run batch processes without duplication/issues with existing data
- There is currently no frontend, the system is managed using the Convex Dashboard
- The system is design for a single user only
- package manager: bun

# Philosophy

- This is a new project which we have started today. There is no existing system or data beyond what exists here, locally.
- Never consider backwards compatibility - make breaking changes, refactor existing code, delete what is no longer relevant.
- Favour pure functions with a single purpose, that can be composed throughout the codebase
- Do not use return types (unless working with generics), they lie to the compiler and cause bugs and inflexibility
- Avoid classes, encapsulation and hierachies.
- Fail fast: Do not catch errors without a specific reason to. Convex logs error data in full automatically.
- Good code is easy to delete. Avoid needless complexity and tightly coupled code.
- We're working with an API that is subject to change at anytime, without warning. Capture the results, then parse them. Abnormalities can be reviewed manually. We don't reject data that doesn't match our naive assumptions.

# Convex

- If you encounter a circular type dependancy issue, it is almost certainly due to type annotations on return values from queries/mutations to actions being required, eg. `const results: Id<'users'> = await ctx.runMutation(internal.users.update, args)`
- Don't return data from functions unless there is a practical reason to, especially actions which almost never need this.
- Actions should almost always be internal, unless you want and end user to use them directly (this is rare).
- asyncMap from convex-helpers is a convenience wrapper around Promise.all. We should use it whenever we need to run multiple db calls at once (like when storing batches)

# CivitAI

The endpoints:

- GET /api/v1/images (the main query that will trigger everything off)
- GET /api/v1/models/:modelId
- GET /api/v1/model-versions/:modelVersionId
- GET /api/v1/model-versions/by-hash/:hash

We don't need currently:

- GET /api/v1/models (we may support this in the future)
- GET /api/v1/creators
- GET /api/v1/tags